{- | An implementation of overloaded record fields.  This module
enables different types in the same module to have fields of the
same name.

To use instances from this class, either:

* Enable the @OverloadedLabels@ extension and
  @import Data.ProtoLens.Labels ()@;
* Use the 'field' function along with the @TypeApplications@ extension; or,
* Import the corresponding names from the autogenerated @*_Fields@ module.

For more information, see <https://google.github.io/proto-lens/tutorial.html#field-overloading>.
-}
{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE MagicHash #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE ScopedTypeVariables #-}
module Data.ProtoLens.Field
    ( HasField(..)
    , field
    ) where

import GHC.Prim (Proxy#, proxy#)
import GHC.TypeLits (Symbol, TypeError, ErrorMessage(..))

-- | A lens for a given field.  For example:
--
-- > view field@"abc" x
-- > set field@"abc" 42 x
field :: forall x s a f . (HasField s x a, Functor f) => (a -> f a) -> s -> f s
field = lensOf (proxy# :: Proxy# x)

-- | A type class for lens fields.
--
-- The instance @HasField s x a@ can be understood as "@s@ has a field named @x@
-- of type @a@".
--
-- Note: in order to support better type error messages, this class does not have
-- a fundep relationship to the parameter @a@.  Instead, instances are expected to
-- be defined such that @a@ is derivable from @s@ and @x@.  For example, to define a
-- field named @"r"@ of type @Int32@ for the containing type @Foo@, use:
--
-- > instance a ~ Int32 => HasField Foo "r" a where ...
--
-- The type checker can use such an instance as long as it knows the types of the
-- `s` and `x` parameters.  In contrast, an @instance HasField Foo "r" Int32@ would
-- not be used unless the type of `a` is also already known to be `Int32`.
class HasField s (x :: Symbol) a where
    lensOf :: Functor f => Proxy# x -> (a -> f a) -> s -> f s

instance {-# OVERLAPPABLE #-} TypeError (MissingInstanceError s x) => HasField s x a where
    lensOf = error "Missing HasField instance"

type MissingInstanceError s (x :: Symbol) =
    'Text "Type " ':<>: 'ShowType s ':<>: 'Text " has no field named " ':<>: 'ShowType x
